{"version":3,"file":"react-decision-tree-flow.cjs.production.min.js","sources":["../src/Shared.tsx","../src/Controls.tsx","../src/Step.tsx","../src/Wizard.tsx"],"sourcesContent":["import React from 'react';\r\n\r\nexport interface Tree {\r\n  readonly [step: string]: readonly string[];\r\n}\r\n\r\nexport type ControlType<T extends Tree> = Record<keyof T, () => void>;\r\n\r\nexport interface WizardContextProps<T extends Tree> {\r\n  tree: T;\r\n  step: string;\r\n  setStep: React.Dispatch<React.SetStateAction<keyof T>>;\r\n  getControls: () => ControlType<T>;\r\n}\r\n\r\nexport const WizardContext = React.createContext<WizardContextProps<any>>({\r\n  tree: {},\r\n  step: '',\r\n  setStep: () => {},\r\n  getControls: () => ({}),\r\n});\r\n","import React, { PropsWithChildren } from 'react';\r\nimport { Tree, WizardContext, WizardContextProps } from './Shared';\r\n\r\nexport interface ControlHook<T extends Tree> {\r\n  step: keyof T;\r\n  tree: T;\r\n  destinations: Record<keyof T, () => void>;\r\n}\r\n\r\nexport function useControls<T extends Tree>(): ControlHook<T> {\r\n  const { getControls, step, tree } = React.useContext(\r\n    WizardContext as React.Context<WizardContextProps<T>>\r\n  );\r\n  return { step, tree, destinations: getControls() };\r\n}\r\n\r\nexport interface ControlProps<T extends Tree> {\r\n  children: (steps: ControlHook<T>) => React.ReactNode;\r\n}\r\n\r\nexport function Controls<T extends Tree>({\r\n  children,\r\n}: PropsWithChildren<ControlProps<T>>) {\r\n  const getControls = useControls<T>();\r\n  return <>{children({ ...getControls })}</>;\r\n}\r\n","import React, { PropsWithChildren } from 'react';\r\nimport { Tree } from './Shared';\r\nimport { useControls } from './Controls';\r\n\r\nexport interface StepProps<T> {\r\n  name: keyof T;\r\n}\r\n\r\nexport function Step<T extends Tree>({\r\n  children,\r\n  name,\r\n}: PropsWithChildren<StepProps<T>>) {\r\n  const { step, tree } = useControls<T>();\r\n\r\n  // Check if name is bad value\r\n  React.useEffect(() => {\r\n    if (!Object.keys(tree).includes(name as string)) {\r\n      console.warn(\r\n        `Step component with name ${name} is not found in step tree!`\r\n      );\r\n    }\r\n  }, [name, tree]);\r\n\r\n  return <>{step === name && children}</>;\r\n}\r\n","import React, { PropsWithChildren, ReactElement } from 'react';\r\nimport { Tree, ControlType, WizardContext } from './Shared';\r\n\r\nexport interface WizardProps<T extends Tree> {\r\n  tree: T;\r\n  first: keyof T;\r\n}\r\n\r\nexport function Wizard<T extends Tree>({\r\n  children,\r\n  tree,\r\n  first,\r\n}: PropsWithChildren<WizardProps<T>>): ReactElement {\r\n  // Check tree for bad values\r\n  React.useEffect(() => {\r\n    const allSteps = Object.keys(tree);\r\n    Object.entries(tree).forEach(([key, dests]) => {\r\n      dests.forEach(d => {\r\n        if (!allSteps.includes(d)) {\r\n          console.warn(\r\n            `Tree definition includes path to ${d} from ${key}. However ${d} is not in tree as a key.`\r\n          );\r\n        }\r\n      });\r\n    });\r\n  }, [tree]);\r\n\r\n  const [step, setStep] = React.useState<keyof T>(first);\r\n\r\n  const getControls = () => {\r\n    const possibleSteps = tree[step];\r\n    return possibleSteps.reduce<ControlType<T>>((accum, step) => {\r\n      const next = {\r\n        [step]: () => {\r\n          setStep(step);\r\n        },\r\n      };\r\n      return {\r\n        ...accum,\r\n        ...next,\r\n      };\r\n    }, {} as ControlType<T>);\r\n  };\r\n\r\n  return (\r\n    <WizardContext.Provider\r\n      value={{\r\n        tree,\r\n        step: step as string,\r\n        setStep: setStep as React.Dispatch<React.SetStateAction<any>>,\r\n        getControls: getControls as () => Record<string, any>,\r\n      }}\r\n    >\r\n      {children}\r\n    </WizardContext.Provider>\r\n  );\r\n}\r\n"],"names":["WizardContext","React","createContext","tree","step","setStep","getControls","useControls","useContext","destinations","children","name","useEffect","Object","keys","includes","console","warn","first","allSteps","entries","forEach","key","d","useState","Provider","value","reduce","accum"],"mappings":"mWAeaA,EAAgBC,EAAMC,cAAuC,CACxEC,KAAM,GACNC,KAAM,GACNC,QAAS,aACTC,YAAa,iBAAO,eCVNC,UACsBN,EAAMO,WACxCR,SAEK,CAAEI,OAHYA,KAGND,OAHYA,KAGNM,cAAcH,IAH3BA,iDAWRI,IAAAA,SAEMJ,EAAcC,WACbN,gCAAGS,OAAcJ,mCCfxBI,IAAAA,SACAC,IAAAA,OAEuBJ,IAAfH,IAAAA,KAAMD,IAAAA,YAGdF,EAAMW,WAAU,WACTC,OAAOC,KAAKX,GAAMY,SAASJ,IAC9BK,QAAQC,iCACsBN,mCAG/B,CAACA,EAAMR,IAEHF,gCAAGG,IAASO,GAAQD,mCCd3BA,IAAAA,SACAP,IAAAA,KACAe,IAAAA,MAGAjB,EAAMW,WAAU,eACRO,EAAWN,OAAOC,KAAKX,GAC7BU,OAAOO,QAAQjB,GAAMkB,SAAQ,gBAAEC,YACvBD,SAAQ,SAAAE,GACPJ,EAASJ,SAASQ,IACrBP,QAAQC,yCAC8BM,WAAUD,eAAgBC,uCAKrE,CAACpB,UAEoBF,EAAMuB,SAAkBN,GAAzCd,OAAMC,cAkBXJ,gBAACD,EAAcyB,UACbC,MAAO,CACLvB,KAAAA,EACAC,KAAMA,EACNC,QAASA,EACTC,YArBc,kBACIH,EAAKC,GACNuB,QAAuB,SAACC,EAAOxB,qBAO7CwB,aALFxB,GAAO,WACNC,EAAQD,UAOX,OAYAM"}